  literal byte definitions
define(`L0_b', `
00000000
0000000000000000
1111111111111111
')
define(`L0_f_b', `    this one has the BFINAL bit set
10000000
0000000000000000
1111111111111111
')
define(`L1_b', `
00000000
1010000000000000
0101111111111111
')
define(`L4_b', `
00000000
0010100000000000
1101011111111111
')
define(`Lh_1_b', `
00000000
1000100000000000
0111011111111111
')
define(`Lt_1_b', `
00000000
1100100000000000
0011011111111111
')

define(`R4_b', `
0                     deflate: R4
10                    fixed huffman codes
0001000               length 10
01000110              distance 20
0001000               length 10
01000110              distance 20
0000000               end of data
')
define(`Rh_1_b', `
0                     deflate: Rh+1 (17, 17) == (9, 17) + (8, 17)
10                    fixed huffman codes
0000111               length 9
01000000              distance 17
0000110               length 8
01000000              distance 17
0000000               end of data
')
define(`Rt_1_b', `
0                     deflate: Rt+1 (19 bytes)
10                    fixed huffman codes
0001000               length 10
01000010              distance 19
0000111               length 9
01000010              distance 19
0000000               end of data
')

C                     zlib: header
0000                  window size, 256 bytes
1000                  compression method, deflate

00                    compression level, fast algorithm
0                     fdict, no dictionary
11101                 checksum

D                     deflate: data start

L0_b                  deflate: nonce blocks to increase the header length. we
L0_b                  need these because later Rh+1 has to take up exactly 5
                      bytes. to make that possible, we insert these nonce bytes
                      in our compressed stream and treat them as part of our
                      header. if we didn't have these, the header would be too
                      short to take up 5 whole bytes of compressed data.

Lh_1_b                deflate: Lh+1 ..H.. Lh+1
C                     ..H..
00001000
00011101
D
L0_b
L0_b
Lh_1_b                Lh+1

Rh_1_b                deflate: Rh+1

L1_b                  deflate: L1 Rh+1
Rh_1_b

L1_b                  deflate: L1 L1
L1_b

L4_b                  deflate: L4 Rh+1 L1 L1 L4
Rh_1_b
L1_b
L1_b
L4_b

R4_b                  deflate: R4

L4_b                  deflate: L4 R4 L4 R4 L4
R4_b
L4_b
R4_b
L4_b

R4_b                  deflate: R4

L4_b                  deflate: L4 R4 L0 L0 Lt+1
R4_b
L0_b
L0_b
Lt_1_b

R4_b                  deflate: R4

L0_b                  deflate: L0

L0_b                  deflate: L0

Lt_1_b                deflate: Lt+1 Rt+1 ..T..
Rt_1_b
L0_b                  ..T..
L0_f_b
C
R
1111000011110000      ..T.. adler32 checksum
1111111111111111
D

Rt_1_b                deflate: Rt+1

                      begin trailer


L0_b                  deflate nonce blocks to pad the trailer
L0_f_b                see header for why this is necessary

C                     adler32 checksum
R
1111000011110000
1111111111111111
